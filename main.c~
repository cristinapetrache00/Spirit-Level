/*********************************************
Project : Test software
**********************************************
Chip type: ATmega164A
Clock frequency: 20 MHz
Compilers:  CVAVR 2.x
*********************************************/

#include <mega164a.h>

#include <stdio.h>
#include <delay.h>  
#include <string.h> 
#include <stdlib.h>
#include <stdint.h>
#include "defs.h"    

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)
{
char status,data;
status=UCSR0A;
data=UDR0;
if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
   {
   rx_buffer0[rx_wr_index0++]=data;
#if RX_BUFFER_SIZE0 == 256
   // special case for receiver buffer size=256
   if (++rx_counter0 == 0) rx_buffer_overflow0=1;
#else
   if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
   if (++rx_counter0 == RX_BUFFER_SIZE0)
      {
      rx_counter0=0;
      rx_buffer_overflow0=1;
      }
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
char data;
while (rx_counter0==0);
data=rx_buffer0[rx_rd_index0++];
#if RX_BUFFER_SIZE0 != 256
if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
#endif
#asm("cli")
--rx_counter0;
#asm("sei")
return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 8
char tx_buffer0[TX_BUFFER_SIZE0];

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
if (tx_counter0)
   {
   --tx_counter0;
   UDR0=tx_buffer0[tx_rd_index0++];
#if TX_BUFFER_SIZE0 != 256
   if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar(char c)
{
while (tx_counter0 == TX_BUFFER_SIZE0);
#asm("cli")
if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
   {
   tx_buffer0[tx_wr_index0++]=c;
#if TX_BUFFER_SIZE0 != 256
   if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
#endif
   ++tx_counter0;
   }
else
   UDR0=c;
#asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//********************END SERIAL STUFF (USART0)  **************************************************
//*************************************************************************************************
//*******   if you need USART1, enable it in Code Wizard and copy coresponding code here  *********
//*************************************************************************************************

/*
 * Timer 1 Output Compare A interrupt is used to blink LED
 */
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
LED1 = ~LED1; // invert LED    
}        

// Read the 8 most significant bits
// of the AD conversion result
unsigned char read_adc(unsigned char adc_input)
{
ADMUX=adc_input | (ADC_VREF_TYPE & 0xff);
// Delay needed for the stabilization of the ADC input voltage
delay_us(10);
// Start the AD conversion
ADCSRA|=0x40;
// Wait for the AD conversion to complete
while ((ADCSRA & 0x10)==0);
ADCSRA|=0x10;
return ADCH;
}                          

/*
 * main function of program
 */  
 
void main (void)
{          
//unsigned char temp,i;

//int8_t xg = 0;
//int8_t yg = 0;
//int8_t zg = 0;

//float X, Y ,Z;
int Axa_X = 107;
int Axa_Y = 107;
int axa = 1;
    
	Init_initController();  // this must be the first "init" action/call!
	#asm("sei")             // enable interrupts
	LED1 = 1;           	// initial state, will be changed by timer 1
             
    PORTB.7 = 1;
    
	while(TRUE)
	{
        switch(axa)
{
    case 1:
    Axa_Y = read_adc(0); 
    delay_ms(10);

    //Cazul in care bolobocul este centrat pe axa Y
    if (Axa_Y > 100 && Axa_Y < 110) {
        //Aprind ledul alb din centru
        PORTC.7 = 1;

        //Sting ledurile de pe axa Y
        PORTC.0 = 0;
        PORTC.1 = 0;
        PORTC.2 = 0;
        PORTC.4 = 0;
        PORTC.3 = 0;
        PORTC.5 = 0;
    } 
    else PORTC.7 = 0;

    //Cazul in care bolobocul este inclinat sub 30 de grade pe axa Y
    if (Axa_Y >= 110 && Axa_Y < 125) {
        //Aprind ledul verde
        PORTC.2 = 1;

        //Sting restul ledurilor de pe axa Y
        PORTC.0 = 0;
        PORTC.1 = 0;
        PORTC.3 = 0;
        PORTC.4 = 0;
        PORTC.5 = 0;
    }

    if (Axa_Y >85 && Axa_Y <= 100) {
        //Aprind ledul verde
        PORTC.3 = 1;

        //Sting restul ledurilor de pe axa Y
        PORTC.0 = 0;
        PORTC.1 = 0;
        PORTC.2 = 0;
        PORTC.4 = 0;
        PORTC.5 = 0;
    }

    //Cazul in care bolobocul este inclinat intre 30-45 de grade pe axa Y
    if (Axa_Y >= 125 && Axa_Y < 140) {
        //Aprind ledul galben
        PORTC.1 = 1;

        //Sting restul ledurilor de pe axa Y
        PORTC.0 = 0;
        PORTC.2 = 0;
        PORTC.3 = 0;
        PORTC.4 = 0;
        PORTC.5 = 0;
    }

    if (Axa_Y > 70 && Axa_Y <= 85) {
        //Aprind ledul galben
        PORTC.4 = 1;

        //Sting restul ledurilor de pe axa Y
        PORTC.0 = 0;
        PORTC.1 = 0;
        PORTC.2 = 0;
        PORTC.3 = 0;
        PORTC.5 = 0;
    }

    //Cazul in care bolobocul este inclinat la peste 45 de grade pe axa Y
    if (Axa_Y >= 140) {
        //Aprind ledul rosu
        PORTC.0 = 1;

        //Sting restul ledurilor de pe axa Y
        PORTC.1 = 0;
        PORTC.2 = 0;
        PORTC.3 = 0;
        PORTC.4 = 0;
        PORTC.5 = 0;
    }

    if (Axa_Y <= 70) {
        //Aprind ledul rosu
        PORTC.5 = 1;

        //Sting restul ledurilor de pe axa Y
        PORTC.0 = 0;
        PORTC.1 = 0;
        PORTC.2 = 0;
        PORTC.3 = 0;
        PORTC.4 = 0;
    }

    delay_ms(200);
    axa = 2;
    break;

    case 2:
    Axa_X = read_adc(1);
    delay_ms(10);

    //Cazul in care bolobocul este centrat pe axa X
	if (Axa_X > 90 && Axa_X < 100) {
		//Aprind ledul alb din centru
		PORTC.7 = 1;

		//Sting ledurile de pe axa X
		PORTB.0 = 0;
		PORTB.1 = 0;
		PORTB.2 = 0;
		PORTB.3 = 0;
		PORTB.4 = 0;
		PORTB.5 = 0;
	}
    else PORTC.7 = 0;

    //Cazul in care bolobocul este inclinat sub 30 grade pe axa X
    if (Axa_X >= 100 && Axa_X < 115) {
        //Aprind ledul verde
        PORTB.2 = 1;

        //Sting restul ledurilor de pe axa X
        PORTB.0 = 0;
        PORTB.1 = 0;
        PORTB.3 = 0;
        PORTB.4 = 0;
        PORTB.5 = 0;
    }
    if (Axa_X > 75 && Axa_X <= 90) {
        //Aprind ledul verde
        PORTB.3 = 1;

        //Sting restul ledurilor de pe axa X
        PORTB.0 = 0;
        PORTB.1 = 0;
        PORTB.2 = 0;
        PORTB.4 = 0;
        PORTB.5 = 0;
    }

    //Cazul in care bolobocul este inclinat intre 30-45 grade pe axa X
    if (Axa_X >= 115 && Axa_X < 130) { 
        //Aprind ledul galben
        PORTB.1 = 1;

        //Sting restul ledurilor de pe axa X
        PORTB.0 = 0;
        PORTB.2 = 0;
        PORTB.3 = 0;
        PORTB.4 = 0;
        PORTB.5 = 0;
    }
    if (Axa_X > 60 && Axa_X <= 75) {
        //Aprind ledul galben
        PORTB.4 = 1;

        //Sting restul ledurilor de pe axa X
        PORTB.0 = 0;
        PORTB.1 = 0;
        PORTB.2 = 0;
        PORTB.3 = 0;
        PORTB.5 = 0;
    }

    //Cazul in care bolobocul este inclinat la peste 45 de grade pe axa X
        if (Axa_X >= 130) {
        //Aprind ledul rosu
        PORTB.0 = 1;

        //Sting restul ledurilor de pe axa X
        PORTB.1 = 0;
        PORTB.2 = 0;
        PORTB.3 = 0;
        PORTB.4 = 0;
        PORTB.5 = 0;
    }
    if (Axa_X <= 60) {
        //Aprind ledul rosu
        PORTB.5 = 1;

        //Sting restul ledurilor de pe axa X
        PORTB.0 = 0;
        PORTB.1 = 0;
        PORTB.2 = 0;
        PORTB.3 = 0;
        PORTB.4 = 0;
    }
    delay_ms(200);
    axa = 1;
    break;
}
    }
           
}// end main loop 


